<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> Java Sequence @  Nazarii's blog</title>
    <link rel="icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/default.css" />
    <meta name="google-site-verification" content="1eqgeS8dNQrx_2L4hO1e5FzIq3AbotzOVmASihAsJVA"/>
    <link href="https://webmention.io/nazarii.bardiuk.com/xmlrpc" rel="pingback"/>
    <link href="https://webmention.io/nazarii.bardiuk.com/webmention" rel="webmention"/>
</head>
<body><header>
    <div class="logo">
        <a href="/">Nazarii's blog</a>
    </div>
</header>
<main role="main">
<article class="h-entry">
    <link class="u-url" href="https://nazarii.bardiuk.com/posts/java-sequence.html">
    <link rel="author" class="p-author h-card" href="/"/>
    <section class="header">
        <h1 class="p-name">Java Sequence</h1>
        Posted on 
        <time class="dt-published" datetime="2016-10-16T00:00:00Z">
            October 16, 2016
        </time>
    </section>
    <section class="e-content" >
        <p>In this article I would like to explore a <code>sequence</code> function and its implementation in Java.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">Applicative&lt;Traversable&lt;T&gt;&gt; sequence(Traversable&lt;Applicative&lt;T&gt;&gt; values)
</code></pre></div><p>You can think about <code>Traversable&lt;T&gt;</code> as an interface that describes a container of values <code>T</code>, something like <code>Iterable&lt;T&gt;</code>. I am going to use <code>T[]</code> and <code>List&lt;T&gt;</code> as an example.</p>
<p><code>Applicative&lt;T&gt;</code> is sort of context for values <code>T</code>, and it allows to join several such values in contexts together. There is no similar interface in Java
but there are several types that have similar behavior.</p>
<p>So sequence is a function that for a given container of wrapped values produces a wrapped container of values.</p>
<p>Let me walk you through some common Java types with Applicative semantics and explain sequencing by example.</p>
<h2 id="optional">Optional</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">Optional&lt;List&lt;T&gt;&gt; sequence(Optional&lt;T&gt; ... optionals)
</code></pre></div><p><code>Optional</code> represents a value that can be absent. Joining together several potentially absent values produces a potentially absent result.</p>
<p>So a sequence of optional values is going to produce an optional list, and it will be present as long as all of optionals are present.</p>
<p>Consider a function <code>parse</code> that extracts a number from a string, if it represents a valid integer.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">Optional&lt;Integer&gt; parse(String number)
</code></pre></div><p>We can use sequence to group individual parsed numbers into parsed list.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">sequence(parse(<span style="font-style:italic">&#34;1&#34;</span>), parse(<span style="font-style:italic">&#34;2&#34;</span>), parse(<span style="font-style:italic">&#34;3&#34;</span>))
<span style="font-style:italic">// Optional[[1,2,3]]
</span><span style="font-style:italic"></span>
sequence(parse(<span style="font-style:italic">&#34;1&#34;</span>), parse(<span style="font-style:italic">&#34;X&#34;</span>), parse(<span style="font-style:italic">&#34;3&#34;</span>))
<span style="font-style:italic">// Optional.empty
</span></code></pre></div><p>Such semantics is useful when we cannot just ignore empty values and need to invalidate the whole list as soon as one of items is empty.</p>
<h2 id="completablefuture">CompletableFuture</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">CompletableFuture&lt;List&lt;T&gt;&gt; sequence(CompletableFuture&lt;T&gt; ... futures)
</code></pre></div><p><code>CompletableFuture</code> is a representation of asynchronous computation that will provide a value in the future.</p>
<p>If we sequence a list of futures it should produce an asynchronous list that is going to be available later, after completion of all futures.</p>
<p>It also has all or nothing semantics - result will be available only after all of futures are completed.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">CompletableFuture&lt;T&gt; async(T i) <span style="font-style:italic">// produces later
</span><span style="font-style:italic"></span>CompletableFuture&lt;T&gt; failed()   <span style="font-style:italic">// finishes exceptionally
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">sequence(async(1), async(2), async(3))
<span style="font-style:italic">// CompletableFuture[[1,2,3]]
</span><span style="font-style:italic"></span>
sequence(async(1), failed(), async(3))
<span style="font-style:italic">// CompletableFuture.failed
</span></code></pre></div><p>It allows to build continuations without blocking on individual results</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">sequence(async(1), async(2), async(3)).thenApply(<span style="font-weight:bold">this</span>::sum)
<span style="font-style:italic">// CompletableFuture[[6]]
</span></code></pre></div><h2 id="list">List</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">List&lt;List&lt;T&gt;&gt; sequence(List&lt;T&gt; ... lists)
</code></pre></div><p>Previously I&rsquo;ve used <code>List</code> as an example for container. But it can also be treated as an Applicative.</p>
<p>List represents a choice between zero to many possible values. Joining several choices together leads to multiplication of possibilities.</p>
<p>In this sense sequence of lists produces their Cartesian product.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">sequence(asList(1, 2), asList(10, 20), asList(100))
<span style="font-style:italic">// [[1, 10, 100], [1, 20, 100], [2, 10, 100], [2, 20, 100]]
</span><span style="font-style:italic"></span>
sequence(asList(1, 2), emptyList(), asList(10, 20))
<span style="font-style:italic">// []
</span></code></pre></div><p>Usually Cartesian product is used to generate combinations of values</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">sequence(asList(<span style="font-style:italic">&#34;J&#34;</span>, <span style="font-style:italic">&#34;Q&#34;</span>, <span style="font-style:italic">&#34;K&#34;</span>, <span style="font-style:italic">&#34;A&#34;</span>), 
         asList(<span style="font-style:italic">&#34;Clubs&#34;</span>, <span style="font-style:italic">&#34;Diamonds&#34;</span>, <span style="font-style:italic">&#34;Hearts&#34;</span>, <span style="font-style:italic">&#34;Spades&#34;</span>))
<span style="font-style:italic">// [[J, Clubs], [J, Diamonds], [J, Hearts], [J, Spades],
</span><span style="font-style:italic"></span><span style="font-style:italic">// [Q, Clubs], [Q, Diamonds], [Q, Hearts], [Q, Spades],
</span><span style="font-style:italic"></span><span style="font-style:italic">// [K, Clubs], [K, Diamonds], [K, Hearts], [K, Spades],
</span><span style="font-style:italic"></span><span style="font-style:italic">// [A, Clubs], [A, Diamonds], [A, Hearts], [A, Spades]]
</span></code></pre></div><h2 id="function">Function</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">Function&lt;A, List&lt;T&gt;&gt; sequence(Function&lt;A, T&gt; ... functions)
BiFunction&lt;A, B, List&lt;T&gt;&gt; sequence(BiFunction&lt;A, B, T&gt; ... functions)
</code></pre></div><p><code>Function</code> can be also viewed as a context for value, a value that will be computed from some key.</p>
<p>Sequence of functions is a function that for a given input computes a list of values.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">sequence(Person::name, Person::surname).apply(person(<span style="font-style:italic">&#34;John&#34;</span>, <span style="font-style:italic">&#34;Doe&#34;</span>))  
<span style="font-style:italic">// [John, Doe]
</span><span style="font-style:italic"></span>
sequence(Integer::sum, Integer::max, Integer::min).apply(100, 200)
<span style="font-style:italic">// [300, 200, 100]
</span></code></pre></div><h2 id="implementation">Implementation</h2>
<p>The most common approach to implement <code>sequence</code> is to fold over items. Java&rsquo;s analogy would be a reduction of <code>Stream</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">&lt;T&gt; Optional&lt;List&lt;T&gt;&gt; sequence(List&lt;Optional&lt;T&gt;&gt; optionals) {
  <span style="font-weight:bold">return</span> optionals.stream().reduce(
<span style="font-style:italic">// Initial value Optional&lt;List&lt;T&gt;&gt;
</span><span style="font-style:italic"></span>    Optional.of(<span style="font-weight:bold">new</span> ArrayList&lt;&gt;()),

<span style="font-style:italic">// Accumulator BiFunction&lt;Optional&lt;List&lt;T&gt;&gt;, Optional&lt;T&gt;, Optional&lt;List&lt;T&gt;&gt;&gt;
</span><span style="font-style:italic"></span>    (result, optional) -&gt; result.flatMap(list -&gt; optional.map(item -&gt; {
      list.add(item);
      <span style="font-weight:bold">return</span> list;
    })),

<span style="font-style:italic">// Combiner BinaryOperator&lt;Optional&lt;List&lt;T&gt;&gt;  
</span><span style="font-style:italic"></span>    (result, chunk) -&gt; result.flatMap(left -&gt; chunk.map(right -&gt; {
      List&lt;T&gt; r = <span style="font-weight:bold">new</span> ArrayList&lt;&gt;(left);
      r.addAll(right);
      <span style="font-weight:bold">return</span> r;
    })));
}
</code></pre></div><p><code>Identity</code> value in reduction is an option of empty list (which is going to be a result if stream is empty). <code>Accumulator</code> joins together previously accumulated optional list and current optional value. Finally <code>combiner</code> takes two optional lists that have been produced in parallel and joins them together.</p>
<p>Note that both accumulator and combiner will produce an empty <code>Optional</code> if at least one of arguments is empty.</p>
<p>Accumulator and combiner has the same structure - if both optionals are present then function is applied to their arguments. Lets exploit this pattern and make some refactoring</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">&lt;T&gt; Optional&lt;List&lt;T&gt;&gt; sequence(List&lt;Optional&lt;T&gt;&gt; optionals) {
  <span style="font-weight:bold">return</span> optionals.stream().reduce(
    pure(emptyList()),
    lift(add()),
    lift(addAll()));
}

&lt;A, B, C&gt; BiFunction&lt;Optional&lt;A&gt;, Optional&lt;B&gt;, Optional&lt;C&gt;&gt;
lift(BiFunction&lt;A, B, C&gt; f) {
  <span style="font-weight:bold">return</span> (oa, ob) -&gt; oa.flatMap(a -&gt; ob.map(b -&gt; f.apply(a, b)));
}

&lt;A&gt; BinaryOperator&lt;Optional&lt;A&gt;&gt; lift(BinaryOperator&lt;A&gt; f) {
  <span style="font-weight:bold">return</span> (oa, ob) -&gt; oa.flatMap(a -&gt; ob.map(b -&gt; f.apply(a, b)));
}

&lt;T&gt; Optional&lt;T&gt; pure(T value) {
  <span style="font-weight:bold">return</span> Optional.of(value);
}

&lt;T&gt; BiFunction&lt;List&lt;T&gt;, T, List&lt;T&gt;&gt; add() {
  <span style="font-weight:bold">return</span> (ts, t) -&gt; {
    ArrayList&lt;T&gt; result = <span style="font-weight:bold">new</span> ArrayList&lt;&gt;(ts);
    result.add(t);
    <span style="font-weight:bold">return</span> result;
  };
}

&lt;T&gt; BinaryOperator&lt;List&lt;T&gt;&gt; addAll() {
  <span style="font-weight:bold">return</span> (ts, ts2) -&gt; {
    ArrayList&lt;T&gt; result = <span style="font-weight:bold">new</span> ArrayList&lt;&gt;(ts);
    result.addAll(ts2);
    <span style="font-weight:bold">return</span> result;
  };
}
</code></pre></div><p>Note 2 functions:</p>
<ul>
<li><code>lift</code> transforms a function to work on <code>Optional</code> arguments</li>
<li><code>pure</code> wraps a value into <code>Optional</code></li>
</ul>
<p>These functions are part of <code>Applicative</code>, an interface which satisfy all previous example types. It means that for all of them reduction will look the same, as soon as we manage to provide <code>lift</code> and <code>pure</code> implementations.</p>
<p>Let&rsquo;s do it for <code>CompletableFuture</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">&lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; 
sequence(List&lt;CompletableFuture&lt;T&gt;&gt; futures) {
  <span style="font-weight:bold">return</span> futures.stream().reduce(
    pure(emptyList()),
    lift(add()),
    lift(addAll()));
}

&lt;T&gt; CompletableFuture&lt;T&gt; pure(T t) {
  <span style="font-weight:bold">return</span> completedFuture(t);
}

&lt;A, B, C&gt; BiFunction&lt;CompletableFuture&lt;A&gt;, CompletableFuture&lt;B&gt;, CompletableFuture&lt;C&gt;&gt;
lift(BiFunction&lt;A, B, C&gt; f) {
  <span style="font-weight:bold">return</span> (fa, fb) -&gt; fa.thenCombine(fb, f);
}

&lt;A&gt; BinaryOperator&lt;CompletableFuture&lt;A&gt;&gt; lift(BinaryOperator&lt;A&gt; f) {
  <span style="font-weight:bold">return</span> (fa, fb) -&gt; fa.thenCombine(fb, f);
}
</code></pre></div><p>Bodies of <code>sequence</code> implementations are identical, that is a place for generalization. Unfortunately Java&rsquo;s type system is not powerful enough to represent generic type with generic parameter, i.e. <a href="http://adriaanm.github.io/files/higher.pdf">Generics of higher kind</a>.</p>
<p>So we cannot extract type safe notion of <code>Applicative</code> for <code>sequence</code> function</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">&lt;T, A <span style="font-weight:bold">extends</span> Applicative&gt; A&lt;List&lt;T&gt;&gt; sequence(A&lt;T&gt; ... applicatives)
</code></pre></div><h2 id="composition">Composition</h2>
<p>Anyway we have a space for reuse. In my daily work Streams become a tool for composition of operations over some collection of items. A situation when I need to implement similar reduction are not unique.</p>
<p>I have two options:</p>
<ul>
<li>collect result to list and use sequence function over it</li>
<li>reimplement the same reduction as above</li>
</ul>
<p>Collections of list to stream usually is a little bit premature. So we need to extract reduction. The way to reuse reduction functionality in <code>Stream</code> API is to create a <code>Collector</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">&lt;T&gt; Collector&lt;Optional&lt;T&gt;, ?, Optional&lt;List&lt;T&gt;&gt;&gt; optionals()

Optional&lt;List&lt;Integer&gt;&gt; result =
  Stream.of(parse(<span style="font-style:italic">&#34;1&#34;</span>), parse(<span style="font-style:italic">&#34;2&#34;</span>), parse(<span style="font-style:italic">&#34;3&#34;</span>)).collect(optionals())
<span style="font-style:italic">//Optional[1, 2, 3]
</span></code></pre></div><p>We can go one step further and generalize resulting container, by using composition of collectors.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">&lt;T, A, R&gt; Collector&lt;Optional&lt;T&gt;, ?, Optional&lt;R&gt;&gt;
optionals(Collector&lt;T, A, R&gt; downstream) {
  <span style="font-weight:bold">return</span> collector(
    lift(downstream.supplier()),
    lift(accumulator(downstream)),
    lift(combiner(downstream)),
    lift(downstream.finisher()));
}
</code></pre></div><p>It takes a collector of values and lifts it into <code>Optional</code> context such that it collects optionals with semantics of <code>sequence</code> operation.</p>
<p>Its implementation is a little bit more involved but has the same approach - it lifts each part of downstream collector into <code>Optional</code> context and constructs a new collector.</p>
<p>The full implementation of collectors for all previous types is in <a href="http://github.com/nbardiuk/sequencedemo">this repo</a></p>
<p>Now we can use it as a last step of stream processing</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">Stream.of(parse(<span style="font-style:italic">&#34;1&#34;</span>), parse(<span style="font-style:italic">&#34;2&#34;</span>)).collect(optionals(toList()))
<span style="font-style:italic">// Optional[[1, 2]]
</span><span style="font-style:italic"></span>
Stream.of(parse(<span style="font-style:italic">&#34;1&#34;</span>), parse(<span style="font-style:italic">&#34;X&#34;</span>)).collect(optionals(toList()))
<span style="font-style:italic">// Optional.empty
</span></code></pre></div><p>Composition of collectors gives us useful flexibility - we can reuse existing collectors from JDK and external libraries.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">Stream.of(async(<span style="font-style:italic">&#34;1&#34;</span>), async(<span style="font-style:italic">&#34;2&#34;</span>), async(<span style="font-style:italic">&#34;3&#34;</span>)).collect(futures(joining(<span style="font-style:italic">&#34;:&#34;</span>)))
<span style="font-style:italic">// CompletableFuture[&#34;1:2:3&#34;]
</span><span style="font-style:italic"></span>
Optional&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; result =
Stream.of(parse(<span style="font-style:italic">&#34;13&#34;</span>), parse(<span style="font-style:italic">&#34;12&#34;</span>), parse(<span style="font-style:italic">&#34;11&#34;</span>))
  .collect(optionals(groupingBy(i -&gt; i % 2 == 0)))
<span style="font-style:italic">// Optional[{false=[11, 13], true=[12]}]
</span></code></pre></div><p>Also we can compose sequencing collectors. Consider a list of futures that will complete with optional result.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">List&lt;CompletableFuture&lt;Optional&lt;Integer&gt;&gt;&gt;
list = asList(async(parse(<span style="font-style:italic">&#34;1&#34;</span>)), async(parse(<span style="font-style:italic">&#34;2&#34;</span>)), async(parse(<span style="font-style:italic">&#34;3&#34;</span>)))
</code></pre></div><p>Using composition of collectors we can decide how much structure should be extracted from list</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">CompletableFuture&lt;List&lt;Optional&lt;Integer&gt;&gt;&gt;
result = list.stream().collect(futures(toList()))
<span style="font-style:italic">// CompletableFuture[[Optional[1], Optional[2], Optional[3]]]
</span><span style="font-style:italic"></span>
CompletableFuture&lt;Optional&lt;List&lt;Integer&gt;&gt;&gt;
result = list.stream().collect(futures(optionals(toList())))
<span style="font-style:italic">// CompletableFuture[Optional[[1, 2, 3]]]
</span></code></pre></div><p>We are not limited here by number of layers that can be composed.</p>
<p>Lets go crazy with functions</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-java" data-lang="java">List&lt;Function&lt;String, CompletableFuture&lt;Optional&lt;Integer&gt;&gt;&gt;&gt;
list = asList(s -&gt; async(parse(s)), s -&gt; async(read(s)))

Function&lt;String, List&lt;CompletableFuture&lt;Optional&lt;Integer&gt;&gt;&gt;&gt;
result = list.stream().collect(functions(toList()))

Function&lt;String, CompletableFuture&lt;List&lt;Optional&lt;Integer&gt;&gt;&gt;&gt;
result = list.stream().collect(functions(futures(toList())))

Function&lt;String, CompletableFuture&lt;Optional&lt;List&lt;Integer&gt;&gt;&gt;&gt;
result = list.stream().collect(functions(futures(optionals(toList()))))
</code></pre></div><p>each composed sequence pushes <code>List</code> deeper and deeper inside a stack of contexts.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope that today you&rsquo;ve learned about <code>Applicative</code> and an operation that it enables - <code>sequence</code>.</p>
<p>Also we have learned that Java type system is not the most powerful but definitely have an API that enables composition.</p>
<p>You can checkout code examples from <a href="http://github.com/nbardiuk/sequencedemo">this repo</a></p>
<p><code>Have a nice hack ;)</code></p>

    </section>
</article>

        </main><footer class="h-card">
    © 2014–2018 <span class="p-name">Nazarii Bardiuk</span>
    <link class="u-url" href="https://nazarii.bardiu.com" rel="me"/>
    <link class="u-email" href="mailto:nazarii@bardiuk.com" rel="me"/>
    <link href="https://github.com/nbardiuk" rel="me"/>
    <link href="https://twitter.com/nbardiuk" rel="me"/>
    <link href="https://mastodon.social/@Nbardiuk" rel="me"/>
</footer>
</body>
</html>
