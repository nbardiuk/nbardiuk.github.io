<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> Game Of Live in Clojure with Quil @  Nazarii's blog</title>
    <link rel="icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/default.css" />
    <meta name="google-site-verification" content="1eqgeS8dNQrx_2L4hO1e5FzIq3AbotzOVmASihAsJVA"/>
    <link href="https://webmention.io/nazarii.bardiuk.com/xmlrpc" rel="pingback"/>
    <link href="https://webmention.io/nazarii.bardiuk.com/webmention" rel="webmention"/>
</head>
<body><header>
    <div class="logo">
        <a href="/">Nazarii's blog</a>
    </div>
</header>
<main role="main">
<article class="h-entry">
    <link class="u-url" href="https://nazarii.bardiuk.com/posts/game-of-live-clojure.html">
    <link rel="author" class="p-author h-card" href="/"/>
    <section class="header">
        <h1 class="p-name">Game Of Live in Clojure with Quil</h1>
        Posted on 
        <time class="dt-published" datetime="2014-11-29T00:00:00Z">
            November 29, 2014
        </time>
    </section>
    <section class="e-content" >
        <p>This is my attempt to implement <a href="http://www.conwaylife.com/wiki/Conway%27s_Game_of_Life">Conway&rsquo;s Game of Life</a> in Clojure using Quil library.</p>
<h2 id="game-of-life">Game of Life</h2>
<p><img src="/images/112P51.gif" style="float: right; margin: 10px;" />
There is an infinite grid of cells that can be alive or dead.
For each iteration state of the grid is recalculated using several rules:</p>
<ul>
<li>Alive cell with 2 or 3 alive neighbors will live, in other cases it will die.</li>
<li>A dead cell will become alive only if it has 3 alive neighbors.</li>
</ul>
<p>Such simple rules create a lot of interesting and complex patterns.
For example, oscillator - a pattern that evolves in itself after number of iterations.</p>
<h2 id="quil">Quil</h2>
<p><a href="http://quil.info">Quil</a> is a Clojure wrapper around Processing.
Dynamic nature of Clojure and simple Processing API for graphics gives ability to quickly prototype algorithmic graphics.
Checkout <a href="https://github.com/quil/quil/wiki/Dynamic-Workflow-%28for-LightTable%29">Quil LightTable tutorial</a> and try their dynamic workflow.</p>
<p>Basic Quil application with <a href="https://github.com/quil/quil/wiki/Functional-mode-%28fun-mode%29">funcional mode</a> consists of 3 main functions:
setup, update and draw. Each function works with the state - a map of everything you need on the scene.
Instead of updating global variables for each frame, Quil gives us an API to deal with program state in a functional way.</p>
<h2 id="setup">Setup</h2>
<p>is called once before the first frame. The main goal is to setup Quil scene and create a state map.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-clojure" data-lang="clojure">(<span style="font-weight:bold">defn </span>setup []
  (q/frame-rate 10)
  (q/color-mode <span style="font-style:italic">:hsb</span>)
  <span style="font-style:italic">; initial state</span>
  {<span style="font-style:italic">:life</span> #{[24 8] [37 8] [17 9]}
   <span style="font-style:italic">:cell-size</span> 5})
</code></pre></div><p>Here <code>:life</code> is a set of all alive cells. Usually, developers implement grid by a twodimensional matrix.
I&rsquo;ve found working with the set just more comfortable for infinitely large grid.</p>
<h2 id="update">Update</h2>
<p>is a function that transforms the state for every frame.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-clojure" data-lang="clojure">(<span style="font-weight:bold">defn </span>update [state]
  (<span style="font-weight:bold">let </span>[life (<span style="font-style:italic">:life</span> state)
        candidates (set (mapcat square life))
        next-life (set (filter #(will-live? life %) candidates))] 
    (assoc state <span style="font-style:italic">:life</span> next-life)))
</code></pre></div><p>First it creates <code>candidates</code> - the set of all alive cells and their empty neighbors.
Only those cells can be alive in the next iteration.
Next it creates <code>next-life</code> set from <code>candidates</code> that will survive this iteration.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-clojure" data-lang="clojure">(<span style="font-weight:bold">defn </span>square [[x y]]
  <span style="font-style:italic">&#34;Gets a 3x3 square of points with a center at point [x y]&#34;</span>
  (for [dx [-1 0 1]
        dy [-1 0 1]]
    [(+ x dx) (+ y dy)]))

(<span style="font-weight:bold">defn </span>alive-neighbors [life point]
  <span style="font-style:italic">&#34;Counts alive neighbors for point [x y]&#34;</span>
  (-&gt;&gt; (neighbors point)
       (filter #(contains? life %)) <span style="font-style:italic">; alive neighbors</span>
       count))

(<span style="font-weight:bold">defn </span>will-live? [life point]
  <span style="font-style:italic">&#34;Checks whether point will live for current life state&#34;</span>
  (<span style="font-weight:bold">let </span>[n (alive-neighbors life point)]
    (or (= n 3) (and (= n 2) (contains? life point)))))
</code></pre></div><h2 id="draw">Draw</h2>
<p>function takes a state and draws a frame.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-clojure" data-lang="clojure">(<span style="font-weight:bold">defn </span>draw [state]
  (q/background 240) <span style="font-style:italic">; background color</span>
  (q/stroke 220) <span style="font-style:italic">; cell border color</span>
  (q/fill 180) <span style="font-style:italic">; cell body color</span>

  (doseq [[x y] (<span style="font-style:italic">:life</span> state)
          <span style="font-style:italic">:let</span> [w (<span style="font-style:italic">:cell-size</span> state)]]
    (q/rect (* w x) (* w y) w w 2)))
</code></pre></div><p>It is simple like that. Just clears scene and draws a square for every alive cell.</p>
<h2 id="tltr">TL;TR</h2>
<p>The whole project with instructions how to run it is available on <a href="http://github.com/nbardiuk/gol">github</a>.
Fill free to play with it.</p>
<p><code>Have a nice hack ;)</code></p>

    </section>
</article>

        </main><footer class="h-card">
    © 2014–2020
    <span class="p-name">Nazarii Bardiuk</span>
    <link class="u-url" href="https://nazarii.bardiu.com" rel="me"/>
    <link class="u-email" href="mailto:nazarii@bardiuk.com" rel="me"/>
    <link href="https://github.com/nbardiuk" rel="me"/>
    <link href="https://twitter.com/nbardiuk" rel="me"/>
    <link href="https://mastodon.social/@Nbardiuk" rel="me"/>
</footer>
</body>
</html>
