<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Nazarii Bardiuk&#39;s blog</title>
        <link>https://nazarii.bardiuk.com/</link>
        <description>Recent content on Nazarii Bardiuk&#39;s blog</description>
        <language>en-us</language>
        <managingEditor>nazarii@bardiuk.com (Nazarii Bardiuk)</managingEditor>
        <webMaster>nazarii@bardiuk.com (Nazarii Bardiuk)</webMaster>
        
        <lastBuildDate>Mon, 05 Oct 2020 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://nazarii.bardiuk.com/feed.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Vim as HTTP client</title>
            <link>https://nazarii.bardiuk.com/posts/vim-curl.html</link>
            <pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate>
            <author>nazarii@bardiuk.com (Nazarii Bardiuk)</author>
            <guid>https://nazarii.bardiuk.com/posts/vim-curl.html</guid>
            <description>&lt;p&gt;Let me share a quick tip on how to use Vim with curl as a simple HTTP client.&lt;/p&gt;
&lt;video width=&#34;95%&#34; autoplay loop&gt;
  &lt;source src=&#34;https://nazarii.bardiuk.com/videos/curl.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;
&lt;p&gt;In the core of this tip is a filter through curl.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-vim&#34; data-lang=&#34;vim&#34;&gt;:!curl --config -&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let us walk through this.&lt;/p&gt;
&lt;h2 id=&#34;vim-filter&#34;&gt;Vim filter&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vimhelp.org/change.txt.html#filter&#34;&gt;&lt;code&gt;:help filter&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A filter is a program that accepts text at standard input, changes it in some way, and sends it to standard output.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can send some buffer lines to an external command, and Vim will replace them with the command output.&lt;/p&gt;
&lt;p&gt;Given a buffer&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;3
2
4
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After filtering lines through the sort command&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-vim&#34; data-lang=&#34;vim&#34;&gt;:%!sort&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The lines are in order.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;1
2
3
4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;curl-configuration-file&#34;&gt;curl configuration file&lt;/h2&gt;
&lt;p&gt;Curl allows passing all command-line flags using a configuration file.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://curl.haxx.se/docs/manpage.html#-K&#34;&gt;&lt;code&gt;--config&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Specify a text file to read curl arguments from. The command line arguments found in the text file will be used as if they were provided on the command line.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Like many command-line apps, curl uses a hyphen (&lt;code&gt;-&lt;/code&gt;) to make the app read file from standard input.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ echo &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;--url http://ifconfig.me --silent&amp;#39;&lt;/span&gt; | curl --config -
1.2.3.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s use this in Vim buffer.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;--url http://ifconfig.me
--silent
--show-error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;run the command&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-vim&#34; data-lang=&#34;vim&#34;&gt;:%!curl --config -&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The buffer now contains a curl response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;1.2.3.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;interactive-approach&#34;&gt;Interactive approach&lt;/h2&gt;
&lt;p&gt;It&amp;rsquo;s hard to iterate over request arguments because the curl command replaces them with the response.&lt;/p&gt;
&lt;p&gt;To make it more interactive, we can duplicate the configuration lines before running the curl.&lt;/p&gt;
&lt;p&gt;Below is a sequence of commands that can help with this&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vip&lt;/code&gt; select all configuration lines using paragraph text object&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; copy selected lines&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P&lt;/code&gt; paste before the cursor&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gv&lt;/code&gt; reselect the lines&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:!curl --config -&lt;/code&gt; run curl on the selection&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Record this into a macro or create a command, and you have an interactive environment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-vimrc&#34; data-lang=&#34;vimrc&#34;&gt;:map &amp;lt;leader&amp;gt;cc vipyPgvO&amp;lt;Esc&amp;gt;O&amp;lt;Esc&amp;gt;gv:!curl --config -&amp;lt;CR&amp;gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The extra bit &lt;code&gt;gvO&amp;lt;Esc&amp;gt;O&amp;lt;Esc&amp;gt;&lt;/code&gt; inserts an empty line between request and response. It helps to make them different paragraphs, distinct text objects.&lt;/p&gt;
&lt;h2 id=&#34;use-a-plugin&#34;&gt;Use a plugin&lt;/h2&gt;
&lt;p&gt;This approach is excellent for a quick hack or an example of using the Vim filter command.&lt;/p&gt;
&lt;p&gt;I don&amp;rsquo;t use it every day. Instead, I prefer to use a plugin like &lt;a href=&#34;https://github.com/diepm/vim-rest-console&#34;&gt;Vim REST Console&lt;/a&gt;.
Compared to the simple curl command, it has several advantages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;has simple HTTP syntax&lt;/li&gt;
&lt;li&gt;supports variables&lt;/li&gt;
&lt;li&gt;does not require escaping POST payload&lt;/li&gt;
&lt;li&gt;formats response payload&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>What I&#39;ve learned during Advent of Code</title>
            <link>https://nazarii.bardiuk.com/posts/adventofcode2017.html</link>
            <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
            <author>nazarii@bardiuk.com (Nazarii Bardiuk)</author>
            <guid>https://nazarii.bardiuk.com/posts/adventofcode2017.html</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;Advent of Code is a series of small programming puzzles for a variety of skill sets and skill levels in any programming language you like.
People use them as a speed contest, interview prep, company training, university coursework, practice problems, or to challenge each other.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://adventofcode.com/about&#34;&gt;About Advent of Code&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Puzzles are fun and Advent of Code has 25 of them!
Tasks are connected by common narrative and are published every day in December until Christmas.
Schedule keeps me motivated to complete each challenge withing days it was published so I can avoid spoilers.
Also on &lt;a href=&#34;https://www.reddit.com/r/adventofcode&#34;&gt;reddit&lt;/a&gt; people discuss their solutions in terms of lines of code, performance or interesting insights they discovered.&lt;/p&gt;
&lt;p&gt;Last year I&amp;rsquo;ve challenged myself to use only TDD and FP in Scala for &lt;a href=&#34;https://github.com/nbardiuk/adventofcode2017&#34;&gt;my solutions&lt;/a&gt;.
I would like to share what I&amp;rsquo;ve learned from the challenge and how I am going to challenge myself this time.&lt;/p&gt;
&lt;h2 id=&#34;tdd&#34;&gt;TDD&lt;/h2&gt;
&lt;p&gt;I restricted myself to pure TDD where I would write minimal test first and then only implement enough to fix failing test.&lt;/p&gt;
&lt;h3 id=&#34;inside-out&#34;&gt;Inside Out&lt;/h3&gt;
&lt;p&gt;My first approach was to decompose puzzle into small problems and start from writing a test for one of them.
It is relaxing coding experience - no need to think.
All hard work was done during design of the test case, all I need to do is just to transform input into correct output.&lt;/p&gt;
&lt;p&gt;For complicated problems if I made a mistake during decomposition I had to not only fix the code but also I had to rewrite the whole test specification. My tests where using private API of algorithm implementation and if it is wrong everything goes to the bin.&lt;/p&gt;
&lt;p&gt;Some challenges where hard for me to implement using only immutable data structures.
So I would cheat with mutable internal state while trying to keep public signature pure.
Mutable state requires more complicated test setup comparing to just passing parameters into a function and checking output.&lt;/p&gt;
&lt;h3 id=&#34;outside-in&#34;&gt;Outside In&lt;/h3&gt;
&lt;p&gt;Next approach was to write test for problem using its public interface.
I could use example scenario from problem definition as my first test case or maybe try to think for something simpler.&lt;/p&gt;
&lt;p&gt;For me it is more satisfying way to code.
It creates a safety net on the perimeter and allows do be more creative inside.&lt;/p&gt;
&lt;p&gt;In this case tests can survive most of internal changes.
The biggest downside I discovered was that some tests had very wide scope. Coding mistakes are harder to debug, it takes longer to find where it went wrong.&lt;/p&gt;
&lt;h3 id=&#34;goof-around&#34;&gt;Goof around&lt;/h3&gt;
&lt;p&gt;I ended up using mixed approach.
If problem wasn&amp;rsquo;t that hard I would just create a test case from example provided in the problem definition.
Or I could start with tests for decomposed problem but as soon as I reach public API I could delete smaller tests.&lt;/p&gt;
&lt;p&gt;My important takeaway was that it is OK to remove some intermediate tests once implementation reaches some end to end functionality.&lt;/p&gt;
&lt;h3 id=&#34;refactoring&#34;&gt;Refactoring&lt;/h3&gt;
&lt;p&gt;Daily challenge consists of 2 parts, where second part would build on top of first one.
Usually first part can be solved using simple suboptimal algorithm but second one requires to optimize it in some way (that I never could guess).
It was great opportunity to practice Kent Beck advice on refactoring&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When you find you have to add a feature to a program, and the program&amp;rsquo;s code is not structured in a convenient way to add the feature, first refactor the program to make it easy to add the feature, then add the feature.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And then I had my own third part for the day - looking others solutions on &lt;a href=&#34;https://www.reddit.com/r/adventofcode&#34;&gt;reddit&lt;/a&gt;.
Sometimes I would come back with new ideas and good tests should keep me safe without spoiling fun.&lt;/p&gt;
&lt;h2 id=&#34;fp-in-scala&#34;&gt;FP in Scala&lt;/h2&gt;
&lt;p&gt;I was interested how far I can get with pure functions to solve algorithmic problems.&lt;/p&gt;
&lt;p&gt;Simple problems are so straightforward in FP that I feel almost like cheating.
I can restate problem definition by composing pure functions and it produces the right answer.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;def&lt;/span&gt; countUnique(passphrases&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;Seq&lt;/span&gt;[&lt;span style=&#34;&#34;&gt;String&lt;/span&gt;])&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;Int&lt;/span&gt; = passphrases.count(unique)
&lt;span style=&#34;font-weight:bold&#34;&gt;def&lt;/span&gt; unique(passphrase&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;String&lt;/span&gt;)&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;Boolean&lt;/span&gt; = unique(words(passphrase))
&lt;span style=&#34;font-weight:bold&#34;&gt;def&lt;/span&gt; words(passphrase&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;String&lt;/span&gt;) &lt;span style=&#34;font-weight:bold&#34;&gt;=&lt;/span&gt; passphrase.split(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;)
&lt;span style=&#34;font-weight:bold&#34;&gt;def&lt;/span&gt; unique[&lt;span style=&#34;&#34;&gt;T&lt;/span&gt;](ts&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;Seq&lt;/span&gt;[&lt;span style=&#34;&#34;&gt;T&lt;/span&gt;])&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;Boolean&lt;/span&gt; = ts.toSet.size == ts.size 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Complex problems require to use another way of thinking.
Lazy Streams and recursion were great tools to keep code pure and readable.
But for some cases I had to fall back to mutable Arrays and Maps.&lt;/p&gt;
&lt;p&gt;Avoidance of mutability stimulated me to explore functional programming beyond what I thought I want.
In one such exploration I&amp;rsquo;ve learned about &lt;a href=&#34;https://en.wikipedia.org/wiki/Fixed-point_combinator&#34;&gt;Fixed-point combinator&lt;/a&gt; and how to &lt;a href=&#34;https://michid.wordpress.com/2009/02/23/function_mem/&#34;&gt;memoize&lt;/a&gt; recursive functions.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;def&lt;/span&gt; fibonachi&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;Int&lt;/span&gt; =&amp;gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Int&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;=&lt;/span&gt;
  fixMemo[&lt;span style=&#34;&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;&#34;&gt;Int&lt;/span&gt;] { fibonachi &lt;span style=&#34;font-weight:bold&#34;&gt;=&amp;gt;&lt;/span&gt; n &lt;span style=&#34;font-weight:bold&#34;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (n == 1 || n == 0) 1
    &lt;span style=&#34;font-weight:bold&#34;&gt;else&lt;/span&gt; fibonachi(n-1) + fibonachi(n-2)
  }(&lt;span style=&#34;font-weight:bold&#34;&gt;_&lt;/span&gt;)

&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;def&lt;/span&gt; fixMemo[&lt;span style=&#34;&#34;&gt;I&lt;/span&gt;, &lt;span style=&#34;&#34;&gt;O&lt;/span&gt;](fix&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;I&lt;/span&gt; =&amp;gt; &lt;span style=&#34;&#34;&gt;O&lt;/span&gt;) &lt;span style=&#34;font-weight:bold&#34;&gt;=&amp;gt;&lt;/span&gt; I &lt;span style=&#34;font-weight:bold&#34;&gt;=&amp;gt;&lt;/span&gt; O)&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;I&lt;/span&gt; =&amp;gt; O &lt;span style=&#34;font-weight:bold&#34;&gt;=&lt;/span&gt; {
  &lt;span style=&#34;font-weight:bold&#34;&gt;lazy&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;val&lt;/span&gt; io&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;I&lt;/span&gt; =&amp;gt; O &lt;span style=&#34;font-weight:bold&#34;&gt;=&lt;/span&gt; memo()(fix(io)(&lt;span style=&#34;font-weight:bold&#34;&gt;_&lt;/span&gt;))
  io
}

&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;def&lt;/span&gt; memo[&lt;span style=&#34;&#34;&gt;I&lt;/span&gt;, &lt;span style=&#34;&#34;&gt;O&lt;/span&gt;](cache&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;mutable.Map&lt;/span&gt;[&lt;span style=&#34;&#34;&gt;I&lt;/span&gt;, &lt;span style=&#34;&#34;&gt;O&lt;/span&gt;] &lt;span style=&#34;font-weight:bold&#34;&gt;=&lt;/span&gt; mutable.&lt;span style=&#34;font-weight:bold&#34;&gt;HashMap&lt;/span&gt;[&lt;span style=&#34;&#34;&gt;I&lt;/span&gt;, &lt;span style=&#34;&#34;&gt;O&lt;/span&gt;]())(
  iToO&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;I&lt;/span&gt; =&amp;gt; O)&lt;span style=&#34;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;&#34;&gt;I&lt;/span&gt; =&amp;gt; O &lt;span style=&#34;font-weight:bold&#34;&gt;=&lt;/span&gt;
  i &lt;span style=&#34;font-weight:bold&#34;&gt;=&amp;gt;&lt;/span&gt; cache.getOrElseUpdate(i, iToO(i)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;this-year&#34;&gt;This year&lt;/h2&gt;
&lt;p&gt;This time I am going to use Haskell.
I want to make sure I don&amp;rsquo;t slip into mutable arrays and maps again.
Also I am interested to see how lazy programming language will affect my approach to solutions.&lt;/p&gt;
&lt;p&gt;My main goal this year is to actually complete all 25 puzzles.
And I expect to learn couple new tricks from fellow puzzle solvers.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>How to Hakyll CircleCI 2.0</title>
            <link>https://nazarii.bardiuk.com/posts/hakyll-circle.html</link>
            <pubDate>Sun, 19 Aug 2018 14:00:00 +0000</pubDate>
            <author>nazarii@bardiuk.com (Nazarii Bardiuk)</author>
            <guid>https://nazarii.bardiuk.com/posts/hakyll-circle.html</guid>
            <description>&lt;p&gt;This post documents my
&lt;a href=&#34;https://github.com/nbardiuk/nbardiuk.github.io/blob/a2745429997f4f66bd488e330f694c60c4624194/.circleci/config.yml&#34;&gt;CircleCI configuration&lt;/a&gt;
that builds Hakyll site and publishes it to GitHub pages.&lt;/p&gt;
&lt;p&gt;It is inspired by configurations found on the Internet.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pbrisbin.com/posts/haskell_project_checklist/#circleyml&#34;&gt;Example of caching dependencies for stack&lt;/a&gt; by Pat Brisbin&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/haskellweekly/haskellweekly.github.io/blob/b9e2f0e70aa0f8fe8d2a427fa6c64ec41a2b7965/tools/deploy.hs&#34;&gt;Old publishing script of haskellweekly blog&lt;/a&gt; by Taylor Fausak&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.stackbuilders.com/news/dr-hakyll-create-a-github-page-with-hakyll-and-circleci&#34;&gt;Guide to publish GitHub page with Hakyll and CircleCI 1.0&lt;/a&gt; by Juan Pedro Villa&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;!-- vim-markdown-toc GFM --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#use-fpcomplete-docker-image&#34;&gt;Use FPComplete docker image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cache-compiled-dependencies&#34;&gt;Cache compiled dependencies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#generate-content&#34;&gt;Generate content&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#push-_site-content-to-github-pages&#34;&gt;Push &lt;code&gt;_site&lt;/code&gt; content to GitHub pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#referrers&#34;&gt;Referrers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- vim-markdown-toc --&gt;
&lt;h2 id=&#34;use-fpcomplete-docker-image&#34;&gt;Use FPComplete docker image&lt;/h2&gt;
&lt;p&gt;Docker is the simplest &lt;a href=&#34;https://circleci.com/docs/2.0/executor-types/#overview&#34;&gt;executor type&lt;/a&gt; on CircleCI.&lt;/p&gt;
&lt;p&gt;This configuration reuses &lt;a href=&#34;https://hub.docker.com/r/fpco/stack-build/&#34;&gt;FPComplete&amp;rsquo;s image&lt;/a&gt; with stack to avoid custom installation scripts.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;docker&lt;/span&gt;:
  - &lt;span style=&#34;font-weight:bold&#34;&gt;image&lt;/span&gt;: fpco/stack-build:lts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cache-compiled-dependencies&#34;&gt;Cache compiled dependencies&lt;/h2&gt;
&lt;p&gt;The job is going to recompile all dependencies on every build because it is
using clean docker image.&lt;/p&gt;
&lt;p&gt;It takes around 20 minutes to build template Hakyll blog.
With &lt;a href=&#34;https://circleci.com/docs/2.0/caching/&#34;&gt;caching configuration&lt;/a&gt; building
time drops to less than a minute.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;- &lt;span style=&#34;font-weight:bold&#34;&gt;restore_cache&lt;/span&gt;:
    &lt;span style=&#34;font-weight:bold&#34;&gt;name&lt;/span&gt;: Restore Cached Dependencies
    &lt;span style=&#34;font-weight:bold&#34;&gt;keys&lt;/span&gt;:
      &lt;span style=&#34;font-style:italic&#34;&gt;# find a cache for the same stack.yaml&lt;/span&gt;
      - stack-{{ .Branch }}-{{ checksum &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;stack.yaml&amp;#34;&lt;/span&gt; }}
      &lt;span style=&#34;font-style:italic&#34;&gt;# when missing reuse from the same branch&lt;/span&gt;
      - stack-{{ .Branch }}&lt;span style=&#34;font-style:italic&#34;&gt;-
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt; &lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;# when missing reuse the latest cache&lt;/span&gt;
      - stack-
- &lt;span style=&#34;font-weight:bold&#34;&gt;run&lt;/span&gt;:
    &lt;span style=&#34;font-weight:bold&#34;&gt;name&lt;/span&gt;: Resolve/Update Dependencies
    &lt;span style=&#34;font-weight:bold&#34;&gt;command&lt;/span&gt;: stack setup
    &lt;span style=&#34;font-weight:bold&#34;&gt;command&lt;/span&gt;: stack build --dependencies-only
- &lt;span style=&#34;font-weight:bold&#34;&gt;save_cache&lt;/span&gt;:
    &lt;span style=&#34;font-weight:bold&#34;&gt;name&lt;/span&gt;: Cache Dependencies
    &lt;span style=&#34;font-weight:bold&#34;&gt;key&lt;/span&gt;: stack-{{ .Branch }}-{{ checksum &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;stack.yaml&amp;#34;&lt;/span&gt; }}
    &lt;span style=&#34;font-weight:bold&#34;&gt;paths&lt;/span&gt;:
      - ~/.stack
      - ./.stack-work
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;generate-content&#34;&gt;Generate content&lt;/h2&gt;
&lt;p&gt;Builds &lt;code&gt;site&lt;/code&gt; application and uses it to generate static content&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;- &lt;span style=&#34;font-weight:bold&#34;&gt;run&lt;/span&gt;:
    &lt;span style=&#34;font-weight:bold&#34;&gt;name&lt;/span&gt;: Build Site App
    &lt;span style=&#34;font-weight:bold&#34;&gt;command&lt;/span&gt;: stack build --pedantic
- &lt;span style=&#34;font-weight:bold&#34;&gt;run&lt;/span&gt;:
    &lt;span style=&#34;font-weight:bold&#34;&gt;name&lt;/span&gt;: Generate Static Site
    &lt;span style=&#34;font-weight:bold&#34;&gt;command&lt;/span&gt;: stack exec site build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;push-_site-content-to-github-pages&#34;&gt;Push &lt;code&gt;_site&lt;/code&gt; content to GitHub pages&lt;/h2&gt;
&lt;p&gt;Here &lt;code&gt;master&lt;/code&gt; branch is not used for version control but rather as production
environment so it makes more sense to keep it clean and wipe previous site
content by &lt;code&gt;git push --force&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;- &lt;span style=&#34;font-weight:bold&#34;&gt;run&lt;/span&gt;:
    &lt;span style=&#34;font-weight:bold&#34;&gt;name&lt;/span&gt;: Publish GitHub Pages
    &lt;span style=&#34;font-weight:bold&#34;&gt;working_directory&lt;/span&gt;: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;./_site&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;font-weight:bold&#34;&gt;command&lt;/span&gt;: &lt;span style=&#34;font-style:italic&#34;&gt;|
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt; &lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;# initalize repo&lt;/span&gt;
      git init
      git config user.name  &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;CircleCI&amp;#39;&lt;/span&gt;
      git config user.email &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;job@circleci.com&amp;#39;&lt;/span&gt;
      &lt;span style=&#34;font-style:italic&#34;&gt;# add generated files&lt;/span&gt;
      git add .
      git commit -m &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;publish $CIRCLE_SHA1 [ci skip]&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;font-style:italic&#34;&gt;# push to pages branch&lt;/span&gt;
      git remote add origin &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;$CIRCLE_REPOSITORY_URL&amp;#34;&lt;/span&gt;
      git push --force origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;referrers&#34;&gt;Referrers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mastodon.social/@Nbardiuk/100577686469743725&#34;&gt;nbardiuk@mastodon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/nbardiuk/status/1031156387185930240&#34;&gt;nbardiuk@twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/haskell/comments/98jtii/how_to_hakyll_circleci_20/&#34;&gt;r/haskell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://haskellweekly.news/issues/121.html&#34;&gt;Hasell Weekly 121&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Java Sequence</title>
            <link>https://nazarii.bardiuk.com/posts/java-sequence.html</link>
            <pubDate>Sun, 16 Oct 2016 22:00:00 +0000</pubDate>
            <author>nazarii@bardiuk.com (Nazarii Bardiuk)</author>
            <guid>https://nazarii.bardiuk.com/posts/java-sequence.html</guid>
            <description>&lt;p&gt;In this article I would like to explore a &lt;code&gt;sequence&lt;/code&gt; function and its implementation in Java.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Applicative&amp;lt;Traversable&amp;lt;T&amp;gt;&amp;gt; sequence(Traversable&amp;lt;Applicative&amp;lt;T&amp;gt;&amp;gt; values)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can think about &lt;code&gt;Traversable&amp;lt;T&amp;gt;&lt;/code&gt; as an interface that describes a container of values &lt;code&gt;T&lt;/code&gt;, something like &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;. I am going to use &lt;code&gt;T[]&lt;/code&gt; and &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; as an example.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Applicative&amp;lt;T&amp;gt;&lt;/code&gt; is sort of context for values &lt;code&gt;T&lt;/code&gt;, and it allows to join several such values in contexts together. There is no similar interface in Java
but there are several types that have similar behavior.&lt;/p&gt;
&lt;p&gt;So sequence is a function that for a given container of wrapped values produces a wrapped container of values.&lt;/p&gt;
&lt;p&gt;Let me walk you through some common Java types with Applicative semantics and explain sequencing by example.&lt;/p&gt;
&lt;h2 id=&#34;optional&#34;&gt;Optional&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; sequence(Optional&amp;lt;T&amp;gt; ... optionals)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; represents a value that can be absent. Joining together several potentially absent values produces a potentially absent result.&lt;/p&gt;
&lt;p&gt;So a sequence of optional values is going to produce an optional list, and it will be present as long as all of optionals are present.&lt;/p&gt;
&lt;p&gt;Consider a function &lt;code&gt;parse&lt;/code&gt; that extracts a number from a string, if it represents a valid integer.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Optional&amp;lt;Integer&amp;gt; parse(String number)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can use sequence to group individual parsed numbers into parsed list.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;sequence(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;))
&lt;span style=&#34;font-style:italic&#34;&gt;// Optional[[1,2,3]]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
sequence(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;))
&lt;span style=&#34;font-style:italic&#34;&gt;// Optional.empty
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Such semantics is useful when we cannot just ignore empty values and need to invalidate the whole list as soon as one of items is empty.&lt;/p&gt;
&lt;h2 id=&#34;completablefuture&#34;&gt;CompletableFuture&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;CompletableFuture&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; sequence(CompletableFuture&amp;lt;T&amp;gt; ... futures)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; is a representation of asynchronous computation that will provide a value in the future.&lt;/p&gt;
&lt;p&gt;If we sequence a list of futures it should produce an asynchronous list that is going to be available later, after completion of all futures.&lt;/p&gt;
&lt;p&gt;It also has all or nothing semantics - result will be available only after all of futures are completed.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;CompletableFuture&amp;lt;T&amp;gt; async(T i) &lt;span style=&#34;font-style:italic&#34;&gt;// produces later
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;CompletableFuture&amp;lt;T&amp;gt; failed()   &lt;span style=&#34;font-style:italic&#34;&gt;// finishes exceptionally
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;sequence(async(1), async(2), async(3))
&lt;span style=&#34;font-style:italic&#34;&gt;// CompletableFuture[[1,2,3]]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
sequence(async(1), failed(), async(3))
&lt;span style=&#34;font-style:italic&#34;&gt;// CompletableFuture.failed
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It allows to build continuations without blocking on individual results&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;sequence(async(1), async(2), async(3)).thenApply(&lt;span style=&#34;font-weight:bold&#34;&gt;this&lt;/span&gt;::sum)
&lt;span style=&#34;font-style:italic&#34;&gt;// CompletableFuture[[6]]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;list&#34;&gt;List&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; sequence(List&amp;lt;T&amp;gt; ... lists)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Previously I&amp;rsquo;ve used &lt;code&gt;List&lt;/code&gt; as an example for container. But it can also be treated as an Applicative.&lt;/p&gt;
&lt;p&gt;List represents a choice between zero to many possible values. Joining several choices together leads to multiplication of possibilities.&lt;/p&gt;
&lt;p&gt;In this sense sequence of lists produces their Cartesian product.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;sequence(asList(1, 2), asList(10, 20), asList(100))
&lt;span style=&#34;font-style:italic&#34;&gt;// [[1, 10, 100], [1, 20, 100], [2, 10, 100], [2, 20, 100]]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
sequence(asList(1, 2), emptyList(), asList(10, 20))
&lt;span style=&#34;font-style:italic&#34;&gt;// []
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Usually Cartesian product is used to generate combinations of values&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;sequence(asList(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;J&amp;#34;&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Q&amp;#34;&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;K&amp;#34;&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;), 
         asList(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Clubs&amp;#34;&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Diamonds&amp;#34;&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Hearts&amp;#34;&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Spades&amp;#34;&lt;/span&gt;))
&lt;span style=&#34;font-style:italic&#34;&gt;// [[J, Clubs], [J, Diamonds], [J, Hearts], [J, Spades],
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// [Q, Clubs], [Q, Diamonds], [Q, Hearts], [Q, Spades],
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// [K, Clubs], [K, Diamonds], [K, Hearts], [K, Spades],
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// [A, Clubs], [A, Diamonds], [A, Hearts], [A, Spades]]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;function&#34;&gt;Function&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Function&amp;lt;A, List&amp;lt;T&amp;gt;&amp;gt; sequence(Function&amp;lt;A, T&amp;gt; ... functions)
BiFunction&amp;lt;A, B, List&amp;lt;T&amp;gt;&amp;gt; sequence(BiFunction&amp;lt;A, B, T&amp;gt; ... functions)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Function&lt;/code&gt; can be also viewed as a context for value, a value that will be computed from some key.&lt;/p&gt;
&lt;p&gt;Sequence of functions is a function that for a given input computes a list of values.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;sequence(Person::name, Person::surname).apply(person(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;John&amp;#34;&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Doe&amp;#34;&lt;/span&gt;))  
&lt;span style=&#34;font-style:italic&#34;&gt;// [John, Doe]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
sequence(Integer::sum, Integer::max, Integer::min).apply(100, 200)
&lt;span style=&#34;font-style:italic&#34;&gt;// [300, 200, 100]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;
&lt;p&gt;The most common approach to implement &lt;code&gt;sequence&lt;/code&gt; is to fold over items. Java&amp;rsquo;s analogy would be a reduction of &lt;code&gt;Stream&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&amp;lt;T&amp;gt; Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; sequence(List&amp;lt;Optional&amp;lt;T&amp;gt;&amp;gt; optionals) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; optionals.stream().reduce(
&lt;span style=&#34;font-style:italic&#34;&gt;// Initial value Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    Optional.of(&lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;()),

&lt;span style=&#34;font-style:italic&#34;&gt;// Accumulator BiFunction&amp;lt;Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;, Optional&amp;lt;T&amp;gt;, Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&amp;gt;
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    (result, optional) -&amp;gt; result.flatMap(list -&amp;gt; optional.map(item -&amp;gt; {
      list.add(item);
      &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; list;
    })),

&lt;span style=&#34;font-style:italic&#34;&gt;// Combiner BinaryOperator&amp;lt;Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;  
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    (result, chunk) -&amp;gt; result.flatMap(left -&amp;gt; chunk.map(right -&amp;gt; {
      List&amp;lt;T&amp;gt; r = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(left);
      r.addAll(right);
      &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; r;
    })));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Identity&lt;/code&gt; value in reduction is an option of empty list (which is going to be a result if stream is empty). &lt;code&gt;Accumulator&lt;/code&gt; joins together previously accumulated optional list and current optional value. Finally &lt;code&gt;combiner&lt;/code&gt; takes two optional lists that have been produced in parallel and joins them together.&lt;/p&gt;
&lt;p&gt;Note that both accumulator and combiner will produce an empty &lt;code&gt;Optional&lt;/code&gt; if at least one of arguments is empty.&lt;/p&gt;
&lt;p&gt;Accumulator and combiner has the same structure - if both optionals are present then function is applied to their arguments. Lets exploit this pattern and make some refactoring&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&amp;lt;T&amp;gt; Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; sequence(List&amp;lt;Optional&amp;lt;T&amp;gt;&amp;gt; optionals) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; optionals.stream().reduce(
    pure(emptyList()),
    lift(add()),
    lift(addAll()));
}

&amp;lt;A, B, C&amp;gt; BiFunction&amp;lt;Optional&amp;lt;A&amp;gt;, Optional&amp;lt;B&amp;gt;, Optional&amp;lt;C&amp;gt;&amp;gt;
lift(BiFunction&amp;lt;A, B, C&amp;gt; f) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; (oa, ob) -&amp;gt; oa.flatMap(a -&amp;gt; ob.map(b -&amp;gt; f.apply(a, b)));
}

&amp;lt;A&amp;gt; BinaryOperator&amp;lt;Optional&amp;lt;A&amp;gt;&amp;gt; lift(BinaryOperator&amp;lt;A&amp;gt; f) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; (oa, ob) -&amp;gt; oa.flatMap(a -&amp;gt; ob.map(b -&amp;gt; f.apply(a, b)));
}

&amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; pure(T value) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; Optional.of(value);
}

&amp;lt;T&amp;gt; BiFunction&amp;lt;List&amp;lt;T&amp;gt;, T, List&amp;lt;T&amp;gt;&amp;gt; add() {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; (ts, t) -&amp;gt; {
    ArrayList&amp;lt;T&amp;gt; result = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(ts);
    result.add(t);
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; result;
  };
}

&amp;lt;T&amp;gt; BinaryOperator&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; addAll() {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; (ts, ts2) -&amp;gt; {
    ArrayList&amp;lt;T&amp;gt; result = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(ts);
    result.addAll(ts2);
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; result;
  };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note 2 functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lift&lt;/code&gt; transforms a function to work on &lt;code&gt;Optional&lt;/code&gt; arguments&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pure&lt;/code&gt; wraps a value into &lt;code&gt;Optional&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These functions are part of &lt;code&gt;Applicative&lt;/code&gt;, an interface which satisfy all previous example types. It means that for all of them reduction will look the same, as soon as we manage to provide &lt;code&gt;lift&lt;/code&gt; and &lt;code&gt;pure&lt;/code&gt; implementations.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s do it for &lt;code&gt;CompletableFuture&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&amp;lt;T&amp;gt; CompletableFuture&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; 
sequence(List&amp;lt;CompletableFuture&amp;lt;T&amp;gt;&amp;gt; futures) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; futures.stream().reduce(
    pure(emptyList()),
    lift(add()),
    lift(addAll()));
}

&amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; pure(T t) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; completedFuture(t);
}

&amp;lt;A, B, C&amp;gt; BiFunction&amp;lt;CompletableFuture&amp;lt;A&amp;gt;, CompletableFuture&amp;lt;B&amp;gt;, CompletableFuture&amp;lt;C&amp;gt;&amp;gt;
lift(BiFunction&amp;lt;A, B, C&amp;gt; f) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; (fa, fb) -&amp;gt; fa.thenCombine(fb, f);
}

&amp;lt;A&amp;gt; BinaryOperator&amp;lt;CompletableFuture&amp;lt;A&amp;gt;&amp;gt; lift(BinaryOperator&amp;lt;A&amp;gt; f) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; (fa, fb) -&amp;gt; fa.thenCombine(fb, f);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bodies of &lt;code&gt;sequence&lt;/code&gt; implementations are identical, that is a place for generalization. Unfortunately Java&amp;rsquo;s type system is not powerful enough to represent generic type with generic parameter, i.e. &lt;a href=&#34;http://adriaanm.github.io/files/higher.pdf&#34;&gt;Generics of higher kind&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So we cannot extract type safe notion of &lt;code&gt;Applicative&lt;/code&gt; for &lt;code&gt;sequence&lt;/code&gt; function&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&amp;lt;T, A &lt;span style=&#34;font-weight:bold&#34;&gt;extends&lt;/span&gt; Applicative&amp;gt; A&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; sequence(A&amp;lt;T&amp;gt; ... applicatives)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;composition&#34;&gt;Composition&lt;/h2&gt;
&lt;p&gt;Anyway we have a space for reuse. In my daily work Streams become a tool for composition of operations over some collection of items. A situation when I need to implement similar reduction are not unique.&lt;/p&gt;
&lt;p&gt;I have two options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;collect result to list and use sequence function over it&lt;/li&gt;
&lt;li&gt;reimplement the same reduction as above&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Collections of list to stream usually is a little bit premature. So we need to extract reduction. The way to reuse reduction functionality in &lt;code&gt;Stream&lt;/code&gt; API is to create a &lt;code&gt;Collector&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&amp;lt;T&amp;gt; Collector&amp;lt;Optional&amp;lt;T&amp;gt;, ?, Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&amp;gt; optionals()

Optional&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result =
  Stream.of(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;)).collect(optionals())
&lt;span style=&#34;font-style:italic&#34;&gt;//Optional[1, 2, 3]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can go one step further and generalize resulting container, by using composition of collectors.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&amp;lt;T, A, R&amp;gt; Collector&amp;lt;Optional&amp;lt;T&amp;gt;, ?, Optional&amp;lt;R&amp;gt;&amp;gt;
optionals(Collector&amp;lt;T, A, R&amp;gt; downstream) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; collector(
    lift(downstream.supplier()),
    lift(accumulator(downstream)),
    lift(combiner(downstream)),
    lift(downstream.finisher()));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It takes a collector of values and lifts it into &lt;code&gt;Optional&lt;/code&gt; context such that it collects optionals with semantics of &lt;code&gt;sequence&lt;/code&gt; operation.&lt;/p&gt;
&lt;p&gt;Its implementation is a little bit more involved but has the same approach - it lifts each part of downstream collector into &lt;code&gt;Optional&lt;/code&gt; context and constructs a new collector.&lt;/p&gt;
&lt;p&gt;The full implementation of collectors for all previous types is in &lt;a href=&#34;http://github.com/nbardiuk/sequencedemo&#34;&gt;this repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now we can use it as a last step of stream processing&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Stream.of(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;)).collect(optionals(toList()))
&lt;span style=&#34;font-style:italic&#34;&gt;// Optional[[1, 2]]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
Stream.of(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt;)).collect(optionals(toList()))
&lt;span style=&#34;font-style:italic&#34;&gt;// Optional.empty
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Composition of collectors gives us useful flexibility - we can reuse existing collectors from JDK and external libraries.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Stream.of(async(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;), async(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;), async(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;)).collect(futures(joining(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;)))
&lt;span style=&#34;font-style:italic&#34;&gt;// CompletableFuture[&amp;#34;1:2:3&amp;#34;]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
Optional&amp;lt;Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt; result =
Stream.of(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;13&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;12&amp;#34;&lt;/span&gt;), parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;11&amp;#34;&lt;/span&gt;))
  .collect(optionals(groupingBy(i -&amp;gt; i % 2 == 0)))
&lt;span style=&#34;font-style:italic&#34;&gt;// Optional[{false=[11, 13], true=[12]}]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Also we can compose sequencing collectors. Consider a list of futures that will complete with optional result.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;List&amp;lt;CompletableFuture&amp;lt;Optional&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;
list = asList(async(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;)), async(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;)), async(parse(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using composition of collectors we can decide how much structure should be extracted from list&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;CompletableFuture&amp;lt;List&amp;lt;Optional&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;
result = list.stream().collect(futures(toList()))
&lt;span style=&#34;font-style:italic&#34;&gt;// CompletableFuture[[Optional[1], Optional[2], Optional[3]]]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
CompletableFuture&amp;lt;Optional&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;
result = list.stream().collect(futures(optionals(toList())))
&lt;span style=&#34;font-style:italic&#34;&gt;// CompletableFuture[Optional[[1, 2, 3]]]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We are not limited here by number of layers that can be composed.&lt;/p&gt;
&lt;p&gt;Lets go crazy with functions&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;List&amp;lt;Function&amp;lt;String, CompletableFuture&amp;lt;Optional&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;&amp;gt;
list = asList(s -&amp;gt; async(parse(s)), s -&amp;gt; async(read(s)))

Function&amp;lt;String, List&amp;lt;CompletableFuture&amp;lt;Optional&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;&amp;gt;
result = list.stream().collect(functions(toList()))

Function&amp;lt;String, CompletableFuture&amp;lt;List&amp;lt;Optional&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;&amp;gt;
result = list.stream().collect(functions(futures(toList())))

Function&amp;lt;String, CompletableFuture&amp;lt;Optional&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;&amp;gt;
result = list.stream().collect(functions(futures(optionals(toList()))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;each composed sequence pushes &lt;code&gt;List&lt;/code&gt; deeper and deeper inside a stack of contexts.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I hope that today you&amp;rsquo;ve learned about &lt;code&gt;Applicative&lt;/code&gt; and an operation that it enables - &lt;code&gt;sequence&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also we have learned that Java type system is not the most powerful but definitely have an API that enables composition.&lt;/p&gt;
&lt;p&gt;You can checkout code examples from &lt;a href=&#34;http://github.com/nbardiuk/sequencedemo&#34;&gt;this repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Have a nice hack ;)&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Monads with Java 8</title>
            <link>https://nazarii.bardiuk.com/posts/java-monad.html</link>
            <pubDate>Sun, 08 Nov 2015 22:00:00 +0000</pubDate>
            <author>nazarii@bardiuk.com (Nazarii Bardiuk)</author>
            <guid>https://nazarii.bardiuk.com/posts/java-monad.html</guid>
            <description>&lt;p&gt;It is a paraphrase to Java of &lt;a href=&#34;http://blog.sigfpe.com/2007/04/trivial-monad.html&#34;&gt;&amp;ldquo;The Trivial Monad&amp;rdquo;&lt;/a&gt; by Dan Piponi with applications for Java developers.&lt;/p&gt;
&lt;h2 id=&#34;an-intuition&#34;&gt;An intuition&lt;/h2&gt;
&lt;p&gt;Monad is like a &amp;hellip;&lt;/p&gt;
&lt;p&gt;There is no good analogy to explain what is monad to new person (&lt;a href=&#34;https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/&#34;&gt;monad tutorial fallacy&lt;/a&gt;). The best way to get it right is just to do some coding. So lets explore simple design pattern - one-way wrapper. Such wrapper can wrap value but can&amp;rsquo;t unwrap it back.&lt;/p&gt;
&lt;p&gt;In Java it can look like simple immutable object&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@ToString @EqualsAndHashCode
&lt;span style=&#34;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Wrap&lt;/span&gt;&amp;lt;T&amp;gt; {
  &lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; T value;
  &lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; Wrap(T value) { &lt;span style=&#34;font-weight:bold&#34;&gt;this&lt;/span&gt;.value = value; }
  &lt;span style=&#34;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Wrap&amp;lt;T&amp;gt; of(T value) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; Wrap&amp;lt;&amp;gt;(value);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This class is just going to wrap a value using factory method &lt;code&gt;of&lt;/code&gt;. There are no getters and setters, but present &lt;code&gt;toString&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt; for convenience (see &lt;a href=&#34;https://projectlombok.org/&#34;&gt;lombok&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;To do something with value we need a method that will apply mapping function and then return new wrapped value. It is important to keep value wrapped so it never escapes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Wrap&lt;/span&gt;&amp;lt;T&amp;gt; {
  &lt;span style=&#34;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;font-weight:bold&#34;&gt;public&lt;/span&gt; &amp;lt;R&amp;gt; Wrap&amp;lt;R&amp;gt; map(Function&amp;lt;T, R&amp;gt; mapper) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; Wrap.of(mapper.apply(value));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Wrap&amp;lt;Integer&amp;gt; a = Wrap.of(1);           &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=1)
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;Wrap&amp;lt;Integer&amp;gt; b = a.map(i -&amp;gt; i + 9);    &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=10)
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;Wrap&amp;lt;Integer&amp;gt; c = b.map(i -&amp;gt; i * 11);   &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=110)
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;a.map(i -&amp;gt; i * 10).map(i -&amp;gt; i + 11);    &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=21)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;OK, now we can do something with this, but usually things are more interesting. After starting using wrapped values here and there we eventually create method like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Wrap&amp;lt;Integer&amp;gt; inc(Integer x) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; Wrap.of(x + 1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;inc&lt;/code&gt; gets a number and then returns a wrapped result. It is very useful business logic and we want to apply it even to wrapped values.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Wrap&amp;lt;Integer&amp;gt; a = Wrap.of(1);     &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=1)
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;a.map(&lt;span style=&#34;font-weight:bold&#34;&gt;this&lt;/span&gt;::inc);                 &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=Wrap(value=2))
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;a.map(&lt;span style=&#34;font-weight:bold&#34;&gt;this&lt;/span&gt;::inc).map(&lt;span style=&#34;font-weight:bold&#34;&gt;this&lt;/span&gt;::inc);  &lt;span style=&#34;font-style:italic&#34;&gt;// !!! COMPILATION ERROR
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;First problem we face is that it wraps already wrapped result. And then we cannot continue applying it - &lt;code&gt;inc&lt;/code&gt; accepts only &lt;code&gt;Integer&lt;/code&gt; but not &lt;code&gt;Wrap&amp;lt;Integer&amp;gt;&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;There should be some way to &lt;code&gt;inc&lt;/code&gt; value and not wrap it again.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Wrap&lt;/span&gt;&amp;lt;T&amp;gt; {
  &lt;span style=&#34;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;font-weight:bold&#34;&gt;public&lt;/span&gt; &amp;lt;R&amp;gt; Wrap&amp;lt;R&amp;gt; flatMap(Function&amp;lt;T, Wrap&amp;lt;R&amp;gt;&amp;gt; mapper) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; mapper.apply(value);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; is still safe - it doesn&amp;rsquo;t give user a plain value but provides it to the mapper.&lt;/p&gt;
&lt;p&gt;Now we can apply &lt;code&gt;inc&lt;/code&gt; several times in chains&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Wrap&amp;lt;Integer&amp;gt; a = Wrap.of(1);              &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=1)
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;a.flatMap(&lt;span style=&#34;font-weight:bold&#34;&gt;this&lt;/span&gt;::inc);                      &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=2)
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;a.flatMap(&lt;span style=&#34;font-weight:bold&#34;&gt;this&lt;/span&gt;::inc).flatMap(&lt;span style=&#34;font-weight:bold&#34;&gt;this&lt;/span&gt;::inc);   &lt;span style=&#34;font-style:italic&#34;&gt;// Wrap(value=3)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Actually &lt;code&gt;flatMap&lt;/code&gt; is more generic then &lt;code&gt;map&lt;/code&gt; and we can implement &lt;code&gt;map&lt;/code&gt; using it&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Wrap&lt;/span&gt;&amp;lt;T&amp;gt; {
  &lt;span style=&#34;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;  &amp;lt;R&amp;gt; Wrap&amp;lt;R&amp;gt; map(Function&amp;lt;T, R&amp;gt; mapper) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; flatMap(mapper.andThen(Wrap::of));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;andThen&lt;/code&gt; composes function with another, passing result of first as argument to the second &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#andThen-java.util.function.Function-&#34;&gt;Function#andThen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now we have all tools to work with our wrapper type. &lt;code&gt;of&lt;/code&gt; wraps a value and &lt;code&gt;flatMap&lt;/code&gt; gives a way to modify it without need to unwrap anything. And we can chain multiple transformations without worry how to unwrap layers of results.&lt;/p&gt;
&lt;p&gt;Basically, this is a monad - type that provides APIs to enclose some value and modify it without exiting enclosed context&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Monad&lt;/span&gt;&amp;lt;T&amp;gt; {
  Monad&amp;lt;T&amp;gt; of(T value);
  &amp;lt;R&amp;gt; Monad&amp;lt;R&amp;gt; flatMap(Function&amp;lt;T, Monad&amp;lt;R&amp;gt;&amp;gt; mapper);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;real-world-problems&#34;&gt;Real world problems&lt;/h2&gt;
&lt;p&gt;In Java there are several monadic types and even more with growing number of libraries. I will use &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&#34;&gt;Optional&lt;/a&gt; next, but these examples can be similarly applied to others.&lt;/p&gt;
&lt;h3 id=&#34;operations-on-optionals&#34;&gt;Operations on Optionals&lt;/h3&gt;
&lt;p&gt;Assume we need to add two optional values. And we don&amp;rsquo;t know how to unwrap them, I mean don&amp;rsquo;t know what to do with empty values. All what we want is only add values together and leave that decision for later&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Optional&amp;lt;Integer&amp;gt; a = ...
Optional&amp;lt;Integer&amp;gt; b = ...
&lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; add(a, b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Such function &lt;code&gt;add&lt;/code&gt; should return new Optional with the result of adding values&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Optional&amp;lt;Integer&amp;gt; add(Optional&amp;lt;Integer&amp;gt; oa, Optional&amp;lt;Integer&amp;gt; ob) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; oa.flatMap(a -&amp;gt; ob.map(b -&amp;gt; a + b));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Lambda inside &lt;code&gt;flatMap&lt;/code&gt; has access to value of &lt;code&gt;oa&lt;/code&gt; and uses it to increment value of &lt;code&gt;ob&lt;/code&gt; similarly to previous &lt;code&gt;inc&lt;/code&gt; function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Optional&amp;lt;Integer&amp;gt; a = Optional.of(13);
Optional&amp;lt;Integer&amp;gt; b = Optional.of(42);
add(a, b);                 &lt;span style=&#34;font-style:italic&#34;&gt;// Optional[55]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;add(a, Optional.empty());  &lt;span style=&#34;font-style:italic&#34;&gt;// Optional.empty
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;add(Optional.empty(), b);  &lt;span style=&#34;font-style:italic&#34;&gt;// Optional.empty
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What if we need to perform other operations? Lets create another method that additionally accepts an operation&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&amp;lt;A, B, R&amp;gt; Optional&amp;lt;R&amp;gt; compute(BiFunction&amp;lt;A, B, R&amp;gt; operation, Optional&amp;lt;A&amp;gt; oa, Optional&amp;lt;B&amp;gt; ob) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; oa.flatMap(a -&amp;gt; ob.map(b -&amp;gt; operation.apply(a, b)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is little bit to verbose but basically &lt;code&gt;compute&lt;/code&gt; applies &lt;code&gt;operation&lt;/code&gt; on values from optionals and returns optional result&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Optional&amp;lt;Integer&amp;gt; a = Optional.of(13);
Optional&amp;lt;Integer&amp;gt; b = Optional.of(42);
BiFunction&amp;lt;Integer, Integer, Integer&amp;gt; plus = (x, y) -&amp;gt; x + y;
BiFunction&amp;lt;Integer, Integer, Integer&amp;gt; times = (x, y) -&amp;gt; x * y;
compute(plus, a, b);    &lt;span style=&#34;font-style:italic&#34;&gt;// Optional[55]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;compute(times, a, b);   &lt;span style=&#34;font-style:italic&#34;&gt;// Optional[546]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;streams-of-optionals&#34;&gt;Streams of Optionals&lt;/h3&gt;
&lt;p&gt;So far so good. But with Java 8 we usually deal with a lot of streams. It is a common case when during pipeline we end up with stream of optional values. Now as we know how to perform operations on optionals lets find a product of all optional values in stream&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Optional&amp;lt;Integer&amp;gt; one = Optional.of(1);
Stream&amp;lt;Optional&amp;lt;Integer&amp;gt;&amp;gt; stream = Stream.of(1, 2, 3, 4).map(Optional::of);
stream.reduce(one, (acc, elem) -&amp;gt; compute(times, acc, elem));  &lt;span style=&#34;font-style:italic&#34;&gt;// Optional[24]
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;stream = Stream.of(Optional.of(10), Optional.empty());
stream.reduce(one, (acc, elem) -&amp;gt; compute(times, acc, elem));  &lt;span style=&#34;font-style:italic&#34;&gt;// Optional.empty
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We provide initial value &lt;code&gt;one&lt;/code&gt; and then compute product of accumulator and each value in stream.&lt;/p&gt;
&lt;p&gt;APIs are not always so friendly. Lets look at the reduce but without initial value&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;stream.reduce((acc, elem) -&amp;gt; compute(times, acc, elem));  &lt;span style=&#34;font-style:italic&#34;&gt;// Optional[Optional[24]]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It wraps result into optional, because stream can be empty and we didn&amp;rsquo;t provide any initial value.&lt;/p&gt;
&lt;h3 id=&#34;flattening&#34;&gt;Flattening&lt;/h3&gt;
&lt;p&gt;How can we deal with optional of optional without unwrapping it?
We can flatten it with &lt;code&gt;flatMap&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Optional&amp;lt;Optional&amp;lt;Integer&amp;gt;&amp;gt; ooa = Optional.of(Optional.of(24));
Optional&amp;lt;Integer&amp;gt; oa = ooa.flatMap(o -&amp;gt; o); &lt;span style=&#34;font-style:italic&#34;&gt;// Optional[24]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Function &lt;code&gt;o -&amp;gt; o&lt;/code&gt; is called identity and actually it is so useful that you can find it in standard library &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#identity--&#34;&gt;Function#identity&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;wrap-up&#34;&gt;Wrap-up&lt;/h2&gt;
&lt;p&gt;Sometimes it is better to operate on monads and leave decision how to unwrap them for later. Consider this next time when you will try to get value from Optional, CompletableFuture or some other monadic type. I hope you&amp;rsquo;ve learned here one or two methods how to simplify your design using operations on Monads.&lt;/p&gt;
&lt;p&gt;Code is available on &lt;a href=&#34;https://gist.github.com/nbardiuk/91793d997bed62f36175&#34;&gt;Gist&lt;/a&gt; - feel free to play with it.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Have a nice hack ;)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;referrers&#34;&gt;Referrers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@afcastano/monads-for-java-developers-part-1-the-optional-monad-aa6e797b8a6e&#34;&gt;Monads for Java developers: Part 1The Optional monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@afcastano/monads-for-java-developers-part-2-the-result-and-log-monads-a9ecc0f231bb&#34;&gt;Monads for Java developers: Part 2Two monads more&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Game Of Live in Clojure with Quil</title>
            <link>https://nazarii.bardiuk.com/posts/game-of-live-clojure.html</link>
            <pubDate>Sat, 29 Nov 2014 06:54:00 +0000</pubDate>
            <author>nazarii@bardiuk.com (Nazarii Bardiuk)</author>
            <guid>https://nazarii.bardiuk.com/posts/game-of-live-clojure.html</guid>
            <description>&lt;p&gt;This is my attempt to implement &lt;a href=&#34;http://www.conwaylife.com/wiki/Conway%27s_Game_of_Life&#34;&gt;Conway&amp;rsquo;s Game of Life&lt;/a&gt; in Clojure using Quil library.&lt;/p&gt;
&lt;h2 id=&#34;game-of-life&#34;&gt;Game of Life&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://nazarii.bardiuk.com/images/112P51.gif&#34; style=&#34;float: right; margin: 10px;&#34; /&gt;
There is an infinite grid of cells that can be alive or dead.
For each iteration state of the grid is recalculated using several rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alive cell with 2 or 3 alive neighbors will live, in other cases it will die.&lt;/li&gt;
&lt;li&gt;A dead cell will become alive only if it has 3 alive neighbors.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Such simple rules create a lot of interesting and complex patterns.
For example, oscillator - a pattern that evolves in itself after number of iterations.&lt;/p&gt;
&lt;h2 id=&#34;quil&#34;&gt;Quil&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://quil.info&#34;&gt;Quil&lt;/a&gt; is a Clojure wrapper around Processing.
Dynamic nature of Clojure and simple Processing API for graphics gives ability to quickly prototype algorithmic graphics.
Checkout &lt;a href=&#34;https://github.com/quil/quil/wiki/Dynamic-Workflow-%28for-LightTable%29&#34;&gt;Quil LightTable tutorial&lt;/a&gt; and try their dynamic workflow.&lt;/p&gt;
&lt;p&gt;Basic Quil application with &lt;a href=&#34;https://github.com/quil/quil/wiki/Functional-mode-%28fun-mode%29&#34;&gt;funcional mode&lt;/a&gt; consists of 3 main functions:
setup, update and draw. Each function works with the state - a map of everything you need on the scene.
Instead of updating global variables for each frame, Quil gives us an API to deal with program state in a functional way.&lt;/p&gt;
&lt;h2 id=&#34;setup&#34;&gt;Setup&lt;/h2&gt;
&lt;p&gt;is called once before the first frame. The main goal is to setup Quil scene and create a state map.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;font-weight:bold&#34;&gt;defn &lt;/span&gt;setup []
  (q/frame-rate 10)
  (q/color-mode &lt;span style=&#34;font-style:italic&#34;&gt;:hsb&lt;/span&gt;)
  &lt;span style=&#34;font-style:italic&#34;&gt;; initial state&lt;/span&gt;
  {&lt;span style=&#34;font-style:italic&#34;&gt;:life&lt;/span&gt; #{[24 8] [37 8] [17 9]}
   &lt;span style=&#34;font-style:italic&#34;&gt;:cell-size&lt;/span&gt; 5})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here &lt;code&gt;:life&lt;/code&gt; is a set of all alive cells. Usually, developers implement grid by a twodimensional matrix.
I&amp;rsquo;ve found working with the set just more comfortable for infinitely large grid.&lt;/p&gt;
&lt;h2 id=&#34;update&#34;&gt;Update&lt;/h2&gt;
&lt;p&gt;is a function that transforms the state for every frame.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;font-weight:bold&#34;&gt;defn &lt;/span&gt;update [state]
  (&lt;span style=&#34;font-weight:bold&#34;&gt;let &lt;/span&gt;[life (&lt;span style=&#34;font-style:italic&#34;&gt;:life&lt;/span&gt; state)
        candidates (set (mapcat square life))
        next-life (set (filter #(will-live? life %) candidates))] 
    (assoc state &lt;span style=&#34;font-style:italic&#34;&gt;:life&lt;/span&gt; next-life)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;First it creates &lt;code&gt;candidates&lt;/code&gt; - the set of all alive cells and their empty neighbors.
Only those cells can be alive in the next iteration.
Next it creates &lt;code&gt;next-life&lt;/code&gt; set from &lt;code&gt;candidates&lt;/code&gt; that will survive this iteration.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;font-weight:bold&#34;&gt;defn &lt;/span&gt;square [[x y]]
  &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Gets a 3x3 square of points with a center at point [x y]&amp;#34;&lt;/span&gt;
  (for [dx [-1 0 1]
        dy [-1 0 1]]
    [(+ x dx) (+ y dy)]))

(&lt;span style=&#34;font-weight:bold&#34;&gt;defn &lt;/span&gt;alive-neighbors [life point]
  &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Counts alive neighbors for point [x y]&amp;#34;&lt;/span&gt;
  (-&amp;gt;&amp;gt; (neighbors point)
       (filter #(contains? life %)) &lt;span style=&#34;font-style:italic&#34;&gt;; alive neighbors&lt;/span&gt;
       count))

(&lt;span style=&#34;font-weight:bold&#34;&gt;defn &lt;/span&gt;will-live? [life point]
  &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Checks whether point will live for current life state&amp;#34;&lt;/span&gt;
  (&lt;span style=&#34;font-weight:bold&#34;&gt;let &lt;/span&gt;[n (alive-neighbors life point)]
    (or (= n 3) (and (= n 2) (contains? life point)))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;draw&#34;&gt;Draw&lt;/h2&gt;
&lt;p&gt;function takes a state and draws a frame.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;font-weight:bold&#34;&gt;defn &lt;/span&gt;draw [state]
  (q/background 240) &lt;span style=&#34;font-style:italic&#34;&gt;; background color&lt;/span&gt;
  (q/stroke 220) &lt;span style=&#34;font-style:italic&#34;&gt;; cell border color&lt;/span&gt;
  (q/fill 180) &lt;span style=&#34;font-style:italic&#34;&gt;; cell body color&lt;/span&gt;

  (doseq [[x y] (&lt;span style=&#34;font-style:italic&#34;&gt;:life&lt;/span&gt; state)
          &lt;span style=&#34;font-style:italic&#34;&gt;:let&lt;/span&gt; [w (&lt;span style=&#34;font-style:italic&#34;&gt;:cell-size&lt;/span&gt; state)]]
    (q/rect (* w x) (* w y) w w 2)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is simple like that. Just clears scene and draws a square for every alive cell.&lt;/p&gt;
&lt;h2 id=&#34;tltr&#34;&gt;TL;TR&lt;/h2&gt;
&lt;p&gt;The whole project with instructions how to run it is available on &lt;a href=&#34;http://github.com/nbardiuk/gol&#34;&gt;github&lt;/a&gt;.
Fill free to play with it.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Have a nice hack ;)&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
